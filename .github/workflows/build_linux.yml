name: Build & Release Linux

on:
  workflow_dispatch:
  push:
    tags:
      - "v*.*.*"

env:
  PYTHONUTF8: 1

permissions:
  contents: write

jobs:
  build-linux:
    # 使用 22.04 以保证绝佳的向后兼容性，并避开 24.04 的动态库冲突 Bug
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install UV
        uses: astral-sh/setup-uv@v5

      # 1. 安装 Linux 打包所需的系统依赖 (包含 lxml 依赖)
      - name: Install System Dependencies for Packaging
        run: |
          sudo apt-get update
          sudo apt-get install -y ruby ruby-dev rubygems build-essential rpm libarchive-tools zstd file libxml2-dev libxslt-dev
          sudo gem install fpm

      # 2. 安装项目依赖
      - name: Install dependencies
        run: uv sync --locked --all-extras --dev

      # 3. 动态注入 Keyring 乱码拦截补丁 (解决系统密钥环乱码导致的崩溃)
      - name: Patch Keyring for Linux
        run: |
          python -c "
          import os
          file_path = 'app/utils/account.py'
          
          if os.path.exists(file_path):
              with open(file_path, 'r', encoding='utf-8') as f:
                  content = f.read()
                  
              patch_code = '''
          # --- Auto-injected by Linux CI ---
          import keyring
          import keyring.core
          _orig_get_password = keyring.core.get_password
          def _safe_get_password(*args, **kwargs):
              try:
                  return _orig_get_password(*args, **kwargs)
              except Exception as e:
                  print(f\"[Linux CI Patch] Ignored Keyring Error: {e}\")
                  return None
          keyring.core.get_password = _safe_get_password
          keyring.get_password = _safe_get_password
          # ---------------------------------
          '''
              
              with open(file_path, 'w', encoding='utf-8') as f:
                  f.write(patch_code + '\n' + content)
              print('Successfully patched account.py for Linux keyring issues.')
          else:
              print(f'Warning: {file_path} not found!')
          "

      # 4. 动态注入入口文件全局拦截补丁 (修复子进程环境变量污染 + SQLite只读报错)
      - name: Patch Entrypoint for Linux
        run: |
          python -c "
          import os
          file_path = 'app.py' 
          
          if os.path.exists(file_path):
              with open(file_path, 'r', encoding='utf-8') as f:
                  content = f.read()
                  
              patch_code = '''
          # --- Auto-injected Global Patch for Linux CI ---
          import os
          import sys
          import sqlite3

          # 1. 修复 Linux 下调用外部浏览器或子进程时的环境变量冲突 (过河拆桥)
          if getattr(sys, 'frozen', False) and sys.platform.startswith('linux'):
              if 'LD_LIBRARY_PATH' in os.environ:
                  os.environ['LD_LIBRARY_PATH'] = os.environ.get('LD_LIBRARY_PATH_ORIG', '')

          # 2. 修复 SQLite 数据库由于沙箱只读导致的报错
          _orig_connect = sqlite3.connect
          def _safe_connect(database, *args, **kwargs):
              try:
                  db_str = str(database)
                  if db_str and db_str != ':memory:' and not db_str.startswith('file:'):
                      user_dir = os.path.expanduser('~/.config/XJTUToolbox')
                      os.makedirs(user_dir, exist_ok=True)
                      db_name = os.path.basename(db_str)
                      database = os.path.join(user_dir, db_name)
              except Exception as e:
                  print(f\"[SQLite Patch Error] {e}\")
              return _orig_connect(database, *args, **kwargs)
          
          sqlite3.connect = _safe_connect
          # -----------------------------------------------
          '''
              
              with open(file_path, 'w', encoding='utf-8') as f:
                  f.write(patch_code + '\n' + content)
              print('Successfully patched app.py for Linux subprocess and SQLite.')
          else:
              print(f'Warning: {file_path} not found!')
          "

      # 5. 运行项目自身的构建脚本
      - name: Build Application
        run: uv run build.py

      # 6. 使用 fpm 生成 deb, rpm, pacman 安装包 (使用外壳脚本启动以切换工作目录)
      - name: Create Linux Packages (DEB, RPM, Pacman)
        run: |
          cd dist/
          VERSION=${GITHUB_REF_NAME#v}
          if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+ ]]; then VERSION="1.0.0"; fi
          
          mkdir -p wrapper/usr/bin
          cat <<'EOF' > wrapper/usr/bin/xjtutoolbox
          #!/bin/sh
          USER_DIR="$HOME/.config/XJTUToolbox"
          mkdir -p "$USER_DIR"
          cd "$USER_DIR" || exit 1
          exec /opt/XJTUToolbox/XJTUToolbox "$@"
          EOF
          chmod +x wrapper/usr/bin/xjtutoolbox

          fpm -s dir -t deb -n xjtutoolbox -v $VERSION -p XJTUToolbox-linux-amd64.deb XJTUToolbox=/opt/ wrapper/usr/bin/xjtutoolbox=/usr/bin/xjtutoolbox
          fpm -s dir -t rpm -n xjtutoolbox -v $VERSION -p XJTUToolbox-linux-x86_64.rpm XJTUToolbox=/opt/ wrapper/usr/bin/xjtutoolbox=/usr/bin/xjtutoolbox
          fpm -s dir -t pacman -n xjtutoolbox -v $VERSION -p XJTUToolbox-linux-x86_64.pkg.tar.zst XJTUToolbox=/opt/ wrapper/usr/bin/xjtutoolbox=/usr/bin/xjtutoolbox

      # 7. 生成 AppImage
      - name: Create AppImage
        run: |
          wget -O appimagetool https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage
          chmod +x appimagetool
          
          mkdir -p AppDir/usr/bin
          cp -r dist/XJTUToolbox/* AppDir/usr/bin/
          
          cat <<'EOF' > AppDir/AppRun
          #!/bin/sh
          USER_DIR="$HOME/.config/XJTUToolbox"
          mkdir -p "$USER_DIR"
          cd "$USER_DIR" || exit 1
          HERE="$(dirname "$(readlink -f "${0}")")"
          exec "${HERE}/usr/bin/XJTUToolbox" "$@"
          EOF
          chmod +x AppDir/AppRun
          
          cat <<EOF > AppDir/xjtutoolbox.desktop
          [Desktop Entry]
          Name=XJTUToolbox
          Exec=xjtutoolbox
          Icon=xjtutoolbox
          Type=Application
          Categories=Utility;
          EOF
          
          echo '<svg width="256" height="256" xmlns="http://www.w3.org/2000/svg"><rect width="256" height="256" fill="#007ACC"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="white" font-size="48" font-family="Arial">XJTU</text></svg>' > AppDir/xjtutoolbox.svg
          
          ./appimagetool --appimage-extract-and-run AppDir dist/XJTUToolbox-linux-x86_64.AppImage

      # 8. 上传 Artifacts 供下载检查
      - name: Upload Artifacts (Linux)
        uses: actions/upload-artifact@v4
        with:
          name: XJTUToolbox-linux
          path: |
            ./dist/XJTUToolbox-linux-amd64.deb
            ./dist/XJTUToolbox-linux-x86_64.rpm
            ./dist/XJTUToolbox-linux-x86_64.pkg.tar.zst
            ./dist/XJTUToolbox-linux-x86_64.AppImage

      # 9. 发布至 Github Releases
      - name: Release Linux
        uses: softprops/action-gh-release@v1
        if: startsWith(github.ref, 'refs/tags/')
        with:
          name: XJTUToolbox ${{ github.ref_name }}
          prerelease: true
          files: |
            ./dist/XJTUToolbox-linux-amd64.deb
            ./dist/XJTUToolbox-linux-x86_64.rpm
            ./dist/XJTUToolbox-linux-x86_64.pkg.tar.zst
            ./dist/XJTUToolbox-linux-x86_64.AppImage
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}