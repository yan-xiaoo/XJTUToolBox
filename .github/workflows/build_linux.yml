name: Build & Release Linux

on:
  workflow_dispatch:
  push:
    tags:
      - "v*.*.*"

env:
  PYTHONUTF8: 1

permissions:
  contents: write

jobs:
  build-linux:
    # 保持 ubuntu-22.04 以提供绝佳的系统向后兼容性
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install UV
        uses: astral-sh/setup-uv@v5

      # 1. 安装系统依赖
      - name: Install System Dependencies for Packaging
        run: |
          sudo apt-get update
          sudo apt-get install -y ruby ruby-dev rubygems build-essential rpm libarchive-tools zstd file libxml2-dev libxslt-dev
          sudo gem install fpm

      # 2. 安装项目依赖
      - name: Install dependencies
        run: uv sync --locked --all-extras --dev

      # 3. 动态注入 Keyring 乱码拦截补丁
      - name: Patch Keyring for Linux
        run: |
          python -c "
          import os
          file_path = 'app/utils/account.py'
          if os.path.exists(file_path):
              with open(file_path, 'r', encoding='utf-8') as f:
                  content = f.read()
              patch_code = '''
          # --- Auto-injected by Linux CI ---
          import keyring
          import keyring.core
          _orig_get_password = keyring.core.get_password
          def _safe_get_password(*args, **kwargs):
              try:
                  return _orig_get_password(*args, **kwargs)
              except Exception as e:
                  print(f\"[Linux CI Patch] Ignored Keyring Error: {e}\")
                  return None
          keyring.core.get_password = _safe_get_password
          keyring.get_password = _safe_get_password
          # ---------------------------------
          '''
              with open(file_path, 'w', encoding='utf-8') as f:
                  f.write(patch_code + '\n' + content)
          "

      # 4. 动态注入入口文件全局拦截补丁 (修复子进程环境变量污染 + SQLite沙箱隔离)
      - name: Patch Entrypoint for Linux
        run: |
          python -c "
          import os
          file_path = 'app.py' 
          if os.path.exists(file_path):
              with open(file_path, 'r', encoding='utf-8') as f:
                  content = f.read()
              patch_code = '''
          # --- Auto-injected Global Patch for Linux CI ---
          import os
          import sys
          import sqlite3

          if getattr(sys, 'frozen', False) and sys.platform.startswith('linux'):
              if 'LD_LIBRARY_PATH' in os.environ:
                  os.environ['LD_LIBRARY_PATH'] = os.environ.get('LD_LIBRARY_PATH_ORIG', '')

          _orig_connect = sqlite3.connect
          def _safe_connect(database, *args, **kwargs):
              try:
                  db_str = str(database)
                  if db_str and db_str != ':memory:' and not db_str.startswith('file:'):
                      user_dir = os.path.expanduser('~/.config/XJTUToolbox')
                      os.makedirs(user_dir, exist_ok=True)
                      db_name = os.path.basename(db_str)
                      database = os.path.join(user_dir, db_name)
              except Exception as e:
                  pass
              return _orig_connect(database, *args, **kwargs)
          
          sqlite3.connect = _safe_connect
          # -----------------------------------------------
          '''
              with open(file_path, 'w', encoding='utf-8') as f:
                  f.write(patch_code + '\n' + content)
          "

      # 5. 运行项目自身的构建脚本
      - name: Build Application
        run: uv run build.py

      # 6. 【新增核心修改】使用 Python 和 Pillow 完美提取 .ico 到 .png
      - name: Extract Icon using Python
        run: |
          uv pip install Pillow
          uv run python -c "
          import os
          from PIL import Image
          ico_path = 'assets/icons/main_icon.ico'
          png_dir = 'dist/wrapper/usr/share/pixmaps'
          
          if os.path.exists(ico_path):
              os.makedirs(png_dir, exist_ok=True)
              # Pillow 自动读取 ico，并在保存时提取最优分辨率图层
              img = Image.open(ico_path)
              img.save(os.path.join(png_dir, 'xjtutoolbox.png'), format='PNG')
              print('Icon converted perfectly!')
          else:
              print(f'Error: {ico_path} not found!')
          "

      # 7. 使用 fpm 生成 deb, rpm, pacman 包
      - name: Create Linux Packages (DEB, RPM, Pacman)
        run: |
          cd dist/
          VERSION=${GITHUB_REF_NAME#v}
          if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+ ]]; then VERSION="1.0.0"; fi
          
          mkdir -p wrapper/usr/bin
          mkdir -p wrapper/usr/share/applications
          
          # 创建启动外壳脚本
          cat <<'EOF' > wrapper/usr/bin/xjtutoolbox
          #!/bin/sh
          USER_DIR="$HOME/.config/XJTUToolbox"
          mkdir -p "$USER_DIR"
          cd "$USER_DIR" || exit 1
          exec /opt/XJTUToolbox/XJTUToolbox "$@"
          EOF
          chmod +x wrapper/usr/bin/xjtutoolbox
          
          # 创建标准的 Linux 桌面快捷方式
          cat <<EOF > wrapper/usr/share/applications/xjtutoolbox.desktop
          [Desktop Entry]
          Name=XJTUToolbox
          Exec=xjtutoolbox
          Icon=xjtutoolbox
          Type=Application
          Categories=Utility;
          Terminal=false
          EOF

          fpm -s dir -t deb -n xjtutoolbox -v $VERSION -p XJTUToolbox-linux-x86_64.deb XJTUToolbox=/opt/ wrapper/usr/bin/xjtutoolbox=/usr/bin/xjtutoolbox wrapper/usr/share/pixmaps/xjtutoolbox.png=/usr/share/pixmaps/xjtutoolbox.png wrapper/usr/share/applications/xjtutoolbox.desktop=/usr/share/applications/xjtutoolbox.desktop
          fpm -s dir -t rpm -n xjtutoolbox -v $VERSION -p XJTUToolbox-linux-x86_64.rpm XJTUToolbox=/opt/ wrapper/usr/bin/xjtutoolbox=/usr/bin/xjtutoolbox wrapper/usr/share/pixmaps/xjtutoolbox.png=/usr/share/pixmaps/xjtutoolbox.png wrapper/usr/share/applications/xjtutoolbox.desktop=/usr/share/applications/xjtutoolbox.desktop
          fpm -s dir -t pacman -n xjtutoolbox -v $VERSION -p XJTUToolbox-linux-x86_64.pkg.tar.zst XJTUToolbox=/opt/ wrapper/usr/bin/xjtutoolbox=/usr/bin/xjtutoolbox wrapper/usr/share/pixmaps/xjtutoolbox.png=/usr/share/pixmaps/xjtutoolbox.png wrapper/usr/share/applications/xjtutoolbox.desktop=/usr/share/applications/xjtutoolbox.desktop

      # 8. 生成 AppImage
      - name: Create AppImage
        run: |
          wget -O appimagetool https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage
          chmod +x appimagetool
          
          mkdir -p AppDir/usr/bin
          cp -r dist/XJTUToolbox/* AppDir/usr/bin/
          
          cat <<'EOF' > AppDir/AppRun
          #!/bin/sh
          USER_DIR="$HOME/.config/XJTUToolbox"
          mkdir -p "$USER_DIR"
          cd "$USER_DIR" || exit 1
          HERE="$(dirname "$(readlink -f "${0}")")"
          exec "${HERE}/usr/bin/XJTUToolbox" "$@"
          EOF
          chmod +x AppDir/AppRun
          
          # 【双重保险】拷贝图标和快捷方式到 AppImage 根目录和内部结构
          cp dist/wrapper/usr/share/applications/xjtutoolbox.desktop AppDir/
          cp dist/wrapper/usr/share/pixmaps/xjtutoolbox.png AppDir/
          cp dist/wrapper/usr/share/pixmaps/xjtutoolbox.png AppDir/.DirIcon
          
          ./appimagetool --appimage-extract-and-run AppDir dist/XJTUToolbox-linux-x86_64.AppImage

      # 9. 上传 Artifacts 供下载检查
      - name: Upload Artifacts (Linux)
        uses: actions/upload-artifact@v4
        with:
          name: XJTUToolbox-linux
          path: |
            ./dist/XJTUToolbox-linux-x86_64.deb
            ./dist/XJTUToolbox-linux-x86_64.rpm
            ./dist/XJTUToolbox-linux-x86_64.pkg.tar.zst
            ./dist/XJTUToolbox-linux-x86_64.AppImage

      # 10. 发布至 Github Releases
      - name: Release Linux
        uses: softprops/action-gh-release@v1
        if: startsWith(github.ref, 'refs/tags/')
        with:
          name: XJTUToolbox ${{ github.ref_name }}
          prerelease: true
          files: |
            ./dist/XJTUToolbox-linux-x86_64.deb
            ./dist/XJTUToolbox-linux-x86_64.rpm
            ./dist/XJTUToolbox-linux-x86_64.pkg.tar.zst
            ./dist/XJTUToolbox-linux-x86_64.AppImage
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}